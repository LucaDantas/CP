Ideia para a crocodilos IOI 2011

A gente pega de cada saída e pra cada nó adjacente que não for uma fonte a gente adiciona num vetor que vai salvar quantos vizinhos são fontes, ou seja quantas vezes ele foi chamado e vai salvar qual o menor e qual o segundo menor caminho, desse modo após ter adicionado todos os vizinhos das fontes a gente vai considerar somente aqueles que foram 'visitados' duas ou mais vezes, ou seja que se a gente chegar nele a gente tem certeza que dá pra chegar em uma fonte, já que existem dois caminhos e o cara só pode bloquear um deles, então com certeza o cara vai querer bloquear o menor caminho possível, logo a gente vai pegar como o valor o segundo menor e esse vai ser o valor necessário pra, estando já nesse vértice chegar a uma saída, ou seja nós podemos considerar esse vértice como uma nova fonte, já que com certeza a partir dele encontraremos uma saída, portanto adicionamos ele no vetor das fontes e adicionamos esse segundo menor valor para chegar a uma saída a todas as arestas que saem dele (não é neceesário adicionar somente nas que não são fontes porque como ele vai se tornar uma saída na próxima iteração não há sentido em ir de uma saída para outra). Desse modo após adicionarmos essa novo vértice como uma posssível saída nós rodamos novamente o processo e desse modo achamos as novas possíveis saídas.
É fácil observar que se rodarmos esse processo 'n' vezes teremos encontrado todas as possíveis saídas e se rodarmos mais uma vez isso não encontrará mais nenhuma nova, porém isso é muito lento para a última subtask da questão. Mas eu acho q passa nas duas primeiras, n tenho muita ctz. (Essa observação vem da mesma ideia do belmann-ford, de q vai relaxando cada 'camada' e tem no máximo n camadas).
Pra otimizar a gente pode só rodar pra cada fonte uma vez e já deixar salvo no vértice adjacente 

Essa porra dá errada pq se eu salvar o cara como fonte mas tiver um outro caminho menor q dá certo lasca. Isso lembra um pouco com dijkstra em que em cada a gente n vai salvar somente a menor distância dele, vai salvar as duas menores e sempre ir usando a segunda, e como as fontes no inicío coloca como todas as saídas dadas no enunciado com distância zero.
